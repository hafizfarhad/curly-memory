from Crypto.Util.number import inverse, long_to_bytes
from Crypto.Util.number import long_to_bytes


# factordb 5799651121402313414755192757274772707425976280005028536015579373200822778215

# Given values
p = 172036442175296373253148927105725488217
q = 337117592532677714973555912658569668821
n = p * q
e = 65537
ct = 35564467443181871548382194457563685181813280050250309106793168283293561033295

# Step 1: Calculate the totient function φ(n)
phi_n = (p - 1) * (q - 1)

# Step 2: Calculate the private key 'd' (modular inverse of e mod φ(n))
d = inverse(e, phi_n)

# Step 3: Decrypt the ciphertext
m = pow(ct, d, n)

# Step 4: Convert the decrypted integer to bytes
decrypted_bytes = long_to_bytes(m)

# Step 5: Strip off leading null bytes if present
decrypted_bytes = decrypted_bytes.lstrip(b'\x00')

# Step 6: Convert to hex and print
hex_representation = decrypted_bytes.hex()
print("Decrypted bytes as hex:", hex_representation)


# Given values from the challenge:
n = 57996511214023134147551927572747727074259762800050285360155793732008227782157
# Decrypted value m0, which is m mod n (obtained earlier):
m0_hex = "3f118a53f6a7f9443b34297773e80cf91470f6fe0768da53973174bcc7e00221"
m0 = int(m0_hex, 16)

# We'll look for a k such that m = m0 + k*n yields a valid flag.
for k in range(1, 10000):  # You might need to adjust the range if necessary.
    candidate = m0 + k * n
    candidate_bytes = long_to_bytes(candidate)
    # Try decoding candidate_bytes:
    try:
        flag_candidate = candidate_bytes.decode('utf-8')
        # Check for common flag pattern:
        if "flag{" in flag_candidate:
            print("Found candidate (k = {}):".format(k))
            print(flag_candidate)
            break
    except UnicodeDecodeError:
        continue
else:
    print("No valid flag candidate found in the search range.")
