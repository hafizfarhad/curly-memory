from Crypto.Util.number import *
from sympy import mod_inverse, isprime
import math

mod = (2 ** 257) - 1

# Given sample outputs from chal.py
s = [
    172574366186522099453152553510286100456045303938970984749671481539126061395150,
    213452098588954785236423789646842880126942747585128221630610137685878670428856,
    120140893586047400115063147533673608428777944254084798923564474540478062421288
]

# Solve for m and c using:
# s1 = (s0 * m + c) % mod
# s2 = (s1 * m + c) % mod

# Step 1: solve for m
numerator = (s[2] - s[1]) % mod
denominator = (s[1] - s[0]) % mod
denominator_inv = mod_inverse(denominator, mod)
m = (numerator * denominator_inv) % mod

# Step 2: solve for c
c = (s[1] - s[0] * m) % mod

print(f"[+] Recovered LCG m = {m}")
print(f"[+] Recovered LCG c = {c}")

# Step 3: Rebuild the generator and recover primes
class LCG:
    def __init__(self, seed, mul, inc, mod):
        self.state = seed
        self.m = mul
        self.c = inc
        self.n = mod

    def next(self):
        self.state = (self.state * self.m + self.c) % self.n
        return self.state

gen = LCG(s[0], m, c, mod)
prime_array = []
while len(prime_array) < 8:
    val = gen.next()
    if isprime(val) and val.bit_length() == 256:
        prime_array.append(val)

print(f"[+] Recovered primes:")
for i, p in enumerate(prime_array):
    print(f"p{i+1} = {p}")
